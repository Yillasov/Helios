"""Models for electronic component vulnerability to High-Power Microwave (HPM) effects."""

from enum import Enum, auto
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple, Any
import numpy as np

from helios.core.data_structures import HPMWaveform
from helios.environment.hpm_coupling import HPMEffect
from helios.utils.logger import get_logger

logger = get_logger(__name__)

class ElectronicComponentType(Enum):
    """Types of electronic components that can be affected by HPM."""
    MICROCONTROLLER = auto()
    FPGA = auto()
    MEMORY = auto()
    POWER_SUPPLY = auto()
    RF_FRONTEND = auto()
    SENSOR = auto()
    COMMUNICATION = auto()
    DISPLAY = auto()

@dataclass
class ComponentVulnerability:
    """Vulnerability profile for an electronic component."""
    component_id: str
    component_type: ElectronicComponentType
    upset_threshold: float = -10.0  # dBm, power level causing temporary malfunction
    damage_threshold: float = 20.0  # dBm, power level causing permanent damage
    recovery_time: float = 5.0      # seconds, time to recover from upset
    frequency_sensitivity: Dict[Tuple[float, float], float] = field(default_factory=dict)  # (freq_min, freq_max) -> sensitivity_factor
    modulation_sensitivity: Dict[str, float] = field(default_factory=dict)  # modulation_type -> sensitivity_factor
    
    def get_frequency_sensitivity(self, frequency: float) -> float:
        """Get sensitivity factor for a specific frequency."""
        for (freq_min, freq_max), factor in self.frequency_sensitivity.items():
            if freq_min <= frequency <= freq_max:
                return factor
        return 1.0  # Default sensitivity factor
    
    def get_modulation_sensitivity(self, modulation_type: str) -> float:
        """Get sensitivity factor for a specific modulation type."""
        return self.modulation_sensitivity.get(modulation_type, 1.0)

class HPMVulnerabilityModel:
    """Model for predicting HPM effects on electronic components."""
    
    def __init__(self):
        """Initialize the HPM vulnerability model."""
        self.components: Dict[str, ComponentVulnerability] = {}
        
    def add_component(self, component: ComponentVulnerability):
        """Add a component to the model."""
        self.components[component.component_id] = component
        logger.debug(f"Added component {component.component_id} to vulnerability model")
        
    def predict_effect(self, 
                      component_id: str, 
                      coupled_power: float, 
                      frequency: float,
                      modulation_type: str = "CW",
                      pulse_width: Optional[float] = None) -> HPMEffect:
        """
        Predict the effect of HPM on a component.
        
        Args:
            component_id: ID of the target component
            coupled_power: Power coupled into the component (dBm)
            frequency: Signal frequency (Hz)
            modulation_type: Type of modulation
            pulse_width: Pulse width in seconds (for pulsed signals)
            
        Returns:
            Predicted HPM effect
        """
        if component_id not in self.components:
            logger.warning(f"Component {component_id} not found in vulnerability model")
            return HPMEffect(
                system_id=component_id,
                effect_type="none",
                severity=0.0,
                duration=0.0,
                description="No effect (component not in vulnerability model)"
            )
            
        component = self.components[component_id]
        
        # Apply frequency and modulation sensitivity factors
        freq_factor = component.get_frequency_sensitivity(frequency)
        mod_factor = component.get_modulation_sensitivity(modulation_type)
        
        # Adjust power based on sensitivity factors
        effective_power = coupled_power * freq_factor * mod_factor
        
        # Determine effect type and severity
        if effective_power >= component.damage_threshold:
            # Permanent damage
            severity = min(1.0, (effective_power - component.damage_threshold) / 30.0 + 0.7)
            return HPMEffect(
                system_id=component_id,
                effect_type="damage",
                severity=severity,
                duration=float('inf'),  # Permanent
                description=f"Permanent damage to {component.component_type.name}"
            )
        elif effective_power >= component.upset_threshold:
            # Temporary upset
            severity = (effective_power - component.upset_threshold) / (component.damage_threshold - component.upset_threshold)
            severity = max(0.1, min(0.7, severity))  # Cap between 0.1 and 0.7
            
            # Calculate duration based on severity and recovery time
            duration = component.recovery_time * severity * 2
            
            return HPMEffect(
                system_id=component_id,
                effect_type="upset",
                severity=severity,
                duration=duration,
                description=f"Temporary upset of {component.component_type.name}"
            )
        else:
            # No effect
            return HPMEffect(
                system_id=component_id,
                effect_type="none",
                severity=0.0,
                duration=0.0,
                description="No effect (below upset threshold)"
            )

    def create_standard_component(self, 
                                component_id: str, 
                                component_type: ElectronicComponentType,
                                base_upset_threshold: float = -10.0,
                                base_damage_threshold: float = 20.0) -> ComponentVulnerability:
        """
        Create a standard component with typical vulnerability characteristics.
        
        Args:
            component_id: Component identifier
            component_type: Type of component
            base_upset_threshold: Base upset threshold in dBm
            base_damage_threshold: Base damage threshold in dBm
            
        Returns:
            ComponentVulnerability object with standard settings
        """
        # Create frequency sensitivity bands (example: more sensitive at certain frequencies)
        freq_sensitivity = {}
        
        # Components are often more vulnerable at their operating frequencies
        if component_type == ElectronicComponentType.MICROCONTROLLER:
            # More sensitive to frequencies that can couple to clock lines
            freq_sensitivity[(100e6, 500e6)] = 1.5  # Clock harmonics
            freq_sensitivity[(1e9, 3e9)] = 1.2      # Common clock frequencies
            recovery_time = 2.0
            
        elif component_type == ElectronicComponentType.RF_FRONTEND:
            # RF components are designed to handle their operating bands
            freq_sensitivity[(0.7e9, 6e9)] = 0.8    # Less sensitive in operating band
            freq_sensitivity[(10e9, 40e9)] = 1.3    # More sensitive at higher frequencies
            recovery_time = 0.5
            
        elif component_type == ElectronicComponentType.POWER_SUPPLY:
            # Power supplies often sensitive to lower frequencies
            freq_sensitivity[(10e3, 10e6)] = 1.4    # More sensitive to low frequencies
            recovery_time = 3.0
            
        else:
            # Default sensitivity bands
            freq_sensitivity[(1e9, 2e9)] = 1.2
            freq_sensitivity[(5e9, 10e9)] = 1.3
            recovery_time = 1.0
            
        # Modulation sensitivity (example: different responses to different modulations)
        mod_sensitivity = {
            "CW": 1.0,                # Baseline
            "AM": 1.1,                # Slightly more effective
            "FM": 0.9,                # Slightly less effective
            "PULSE": 1.3,             # Pulsed signals often more effective
            "CHIRP": 1.2              # Frequency sweeping can be more effective
        }
        
        return ComponentVulnerability(
            component_id=component_id,
            component_type=component_type,
            upset_threshold=base_upset_threshold,
            damage_threshold=base_damage_threshold,
            recovery_time=recovery_time,
            frequency_sensitivity=freq_sensitivity,
            modulation_sensitivity=mod_sensitivity
        )