"""Component-level vulnerability models for RF effects."""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Dict, List, Optional, Tuple, Any
import numpy as np

from helios.core.data_structures import ModulationType
from helios.effects.susceptibility import ComponentSusceptibility, EffectType
from helios.utils.logger import get_logger

logger = get_logger(__name__)

class ComponentCategory(Enum):
    """Categories of electronic components with similar vulnerability profiles."""
    PROCESSOR = auto()
    MEMORY = auto()
    POWER_SUPPLY = auto()
    RF_FRONTEND = auto()
    ANALOG_CIRCUIT = auto()
    DIGITAL_CIRCUIT = auto()
    SENSOR = auto()
    DISPLAY = auto()
    COMMUNICATION = auto()
    CONTROL_SYSTEM = auto()

class VulnerabilityLevel(Enum):
    """Vulnerability levels for components."""
    NEGLIGIBLE = 0
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    CRITICAL = 4

@dataclass
class FrequencyResponse:
    """Frequency-dependent response characteristics."""
    frequency_range: Tuple[float, float]  # Hz
    resonant_frequencies: List[float] = field(default_factory=list)  # Hz
    attenuation_factor: float = 1.0  # Default: no attenuation
    
    def get_response(self, frequency: float) -> float:
        """Calculate response factor at a specific frequency."""
        # Check if in range
        min_freq, max_freq = self.frequency_range
        if not (min_freq <= frequency <= max_freq):
            return 0.0
            
        # Check for resonance (higher vulnerability at resonant frequencies)
        for res_freq in self.resonant_frequencies:
            # Simple resonance model - can be made more sophisticated
            if abs(frequency - res_freq) < 0.05 * res_freq:  # Within 5% of resonant frequency
                # Resonance amplification
                return 2.0 / self.attenuation_factor
                
        return 1.0 / self.attenuation_factor

@dataclass
class ComponentVulnerabilityModel(ComponentSusceptibility):
    """Enhanced vulnerability model for electronic components."""
    
    # Component categorization
    category: ComponentCategory = ComponentCategory.DIGITAL_CIRCUIT
    vulnerability_level: VulnerabilityLevel = VulnerabilityLevel.MEDIUM
    
    # Physical characteristics affecting vulnerability
    shielding_effectiveness: float = 0.0  # dB
    grounding_quality: float = 1.0  # 0-1 scale
    filtering_effectiveness: float = 0.0  # dB
    
    # Frequency response characteristics
    frequency_responses: List[FrequencyResponse] = field(default_factory=list)
    
    # Vulnerability to specific waveform characteristics
    pulse_vulnerability: Dict[str, float] = field(default_factory=dict)  # pulse width -> factor
    modulation_vulnerability: Dict[ModulationType, float] = field(default_factory=dict)
    
    # Thermal characteristics
    thermal_time_constant: float = 1.0  # seconds
    thermal_damage_threshold: float = 85.0  # °C
    
    # Failure modes
    failure_modes: Dict[EffectType, float] = field(default_factory=dict)  # Effect type -> probability
    
    def __post_init__(self):
        """Initialize default values if not provided."""
        super().__post_init__()
        
        # Set default pulse vulnerability if not provided
        if not self.pulse_vulnerability:
            self.pulse_vulnerability = {
                "1e-9": 0.8,   # 1 ns pulses
                "1e-6": 1.0,   # 1 μs pulses
                "1e-3": 1.2,   # 1 ms pulses
            }
        
        # Set default modulation vulnerability if not provided
        if not self.modulation_vulnerability:
            self.modulation_vulnerability = {
                ModulationType.AM: 1.0,
                ModulationType.FM: 0.9,
                ModulationType.PSK: 1.1,
                ModulationType.OFDM: 1.2,
            }
        
        # Set default failure modes if not provided
        if not self.failure_modes:
            self.failure_modes = {
                EffectType.INTERFERENCE: 0.8,
                EffectType.UPSET: 0.5,
                EffectType.LATCH_UP: 0.3,
                EffectType.BURNOUT: 0.1,
            }
    
    def calculate_vulnerability(self, 
                               frequency: float, 
                               power: float, 
                               modulation_type: Optional[ModulationType] = None,
                               pulse_width: Optional[float] = None) -> Dict[EffectType, float]:
        """
        Calculate vulnerability to different effect types for given signal parameters.
        
        Args:
            frequency: Signal frequency in Hz
            power: Signal power in dBm
            modulation_type: Type of modulation
            pulse_width: Pulse width in seconds (if applicable)
            
        Returns:
            Dictionary mapping effect types to probability (0-1)
        """
        # Apply shielding and filtering
        effective_power = power - self.shielding_effectiveness - self.filtering_effectiveness
        
        # Apply frequency response
        freq_factor = 1.0
        for resp in self.frequency_responses:
            resp_factor = resp.get_response(frequency)
            if resp_factor > freq_factor:
                freq_factor = resp_factor
        
        effective_power += 10 * np.log10(freq_factor)
        
        # Apply modulation factor
        mod_factor = 1.0
        if modulation_type and modulation_type in self.modulation_vulnerability:
            mod_factor = self.modulation_vulnerability[modulation_type]
        
        # Apply pulse width factor
        pulse_factor = 1.0
        if pulse_width:
            # Find closest pulse width in the dictionary
            closest_pw = min(self.pulse_vulnerability.keys(), 
                            key=lambda x: abs(float(x) - pulse_width))
            pulse_factor = self.pulse_vulnerability[closest_pw]
        
        # Calculate effect probabilities
        result = {}
        for effect_type, base_prob in self.failure_modes.items():
            # Determine power threshold for this effect
            if effect_type == EffectType.INTERFERENCE:
                threshold = self.upset_threshold - 10  # 10dB below upset
            elif effect_type in [EffectType.UPSET, EffectType.LATCH_UP]:
                threshold = self.upset_threshold
            else:  # Damage effects
                threshold = self.damage_threshold
            
            # Calculate probability based on power level relative to threshold
            power_margin = effective_power - threshold
            if power_margin <= -20:
                prob = 0.0
            elif power_margin >= 20:
                prob = base_prob
            else:
                # Linear interpolation between 0 and base_prob
                prob = base_prob * (power_margin + 20) / 40
            
            # Apply modulation and pulse factors
            prob *= mod_factor * pulse_factor
            
            # Apply vulnerability level scaling
            prob *= (self.vulnerability_level.value + 1) / 3
            
            # Clamp to valid range
            result[effect_type] = max(0.0, min(1.0, prob))
        
        return result

# Pre-defined vulnerability models for common components

def create_processor_model(component_id: str, vulnerability: VulnerabilityLevel = VulnerabilityLevel.MEDIUM) -> ComponentVulnerabilityModel:
    """Create a vulnerability model for a processor."""
    return ComponentVulnerabilityModel(
        component_id=component_id,
        component_type="processor",
        category=ComponentCategory.PROCESSOR,
        vulnerability_level=vulnerability,
        upset_threshold=15.0,
        damage_threshold=35.0,
        shielding_effectiveness=5.0,
        frequency_responses=[
            FrequencyResponse(
                frequency_range=(800e6, 5e9),
                resonant_frequencies=[1.8e9, 2.4e9],
                attenuation_factor=0.8
            )
        ],
        modulation_factors={
            "PSK": 1.2,
            "OFDM": 1.3
        }
    )

def create_memory_model(component_id: str, vulnerability: VulnerabilityLevel = VulnerabilityLevel.MEDIUM) -> ComponentVulnerabilityModel:
    """Create a vulnerability model for memory."""
    return ComponentVulnerabilityModel(
        component_id=component_id,
        component_type="memory",
        category=ComponentCategory.MEMORY,
        vulnerability_level=vulnerability,
        upset_threshold=12.0,  # More sensitive than processors
        damage_threshold=30.0,
        shielding_effectiveness=3.0,
        frequency_responses=[
            FrequencyResponse(
                frequency_range=(500e6, 3e9),
                resonant_frequencies=[1.2e9],
                attenuation_factor=0.9
            )
        ]
    )

def create_rf_frontend_model(component_id: str, vulnerability: VulnerabilityLevel = VulnerabilityLevel.HIGH) -> ComponentVulnerabilityModel:
    """Create a vulnerability model for RF frontend components."""
    return ComponentVulnerabilityModel(
        component_id=component_id,
        component_type="rf_frontend",
        category=ComponentCategory.RF_FRONTEND,
        vulnerability_level=vulnerability,
        upset_threshold=10.0,  # Very sensitive
        damage_threshold=25.0,
        shielding_effectiveness=2.0,
        frequency_responses=[
            FrequencyResponse(
                frequency_range=(100e6, 10e9),
                resonant_frequencies=[900e6, 1.8e9, 2.4e9, 5.8e9],
                attenuation_factor=0.7
            )
        ],
        modulation_factors={
            "AM": 1.3,
            "FM": 1.2,
            "PSK": 1.4
        }
    )

def create_power_supply_model(component_id: str, vulnerability: VulnerabilityLevel = VulnerabilityLevel.MEDIUM) -> ComponentVulnerabilityModel:
    """Create a vulnerability model for power supply components."""
    return ComponentVulnerabilityModel(
        component_id=component_id,
        component_type="power_supply",
        category=ComponentCategory.POWER_SUPPLY,
        vulnerability_level=vulnerability,
        upset_threshold=18.0,
        damage_threshold=38.0,
        shielding_effectiveness=8.0,  # Usually better shielded
        frequency_responses=[
            FrequencyResponse(
                frequency_range=(10e3, 500e6),  # More sensitive to lower frequencies
                resonant_frequencies=[50e3, 100e3],
                attenuation_factor=0.6
            )
        ]
    )